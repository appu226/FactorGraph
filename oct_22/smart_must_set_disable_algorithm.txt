C1   C2         C3
a1   a1,a2    ~a3  : Xbar variables (partial assignment a1=a2=0, a3=1)

  a1,     a2,      ~a3
  C1      C2       C3
  C2      C23      C35
  C23              C23
                   
1. Given a MUC on Xbar variables, we have a corr. partial assignment on the X variables.
2. We check if this partial assignment satisfies the given overapprox obtained from MP algorithm
3. If not, nothing to do (all extensions of this partial assignment are already excluded from the overapprox)
   else, we need to remove all extensions of this partial assignment from the overapprox. Conjoin neg of 
   partial assignment with overapprox.
4. We'd like to avoid future MUC's that give rise to a partial assignment that is an extension of the
   the current partial assignment.
   
    How do we inform MUST about what clauses not to consider?
    
       Choose a clause for b1:   C1  (record that C1 was chosen for b1)
         Remove all literals from our partial assignment that are covered by C1 (i.e. b1, b2)
       Choose a clause for b3 (remaining):  C2
       	* Check if the last clause chosen (C2) already works for any prev lit (b1) for which a clause (C1) was chosen
       	If yes, then we backtrack:  Don't choose C2
       	else, go ahead
       	
       	     b1    b2      b3
       	     C1    C1      C7
       	     C7    C2      C2
       	           C5      C3
       	           C6
       	           
   Choice:   C1
                           C2
             C1              
             		   C3
             C7
                   C2
             C7 
                   C5
             C7
                   C6
                   
  ZDD/other library opns: creating an empty set, adding an element, removing an element, check membership, 
  			  iterate through members, union of sets
             for each lit, given set of clauses
             for each clause, given set of lit
             given a list of literals: B
             blacklist of literals
             blacklist of clauses
             pick first literal b1 in B
             pick first clause b1_1 that contains b1
             add b1_1 literals to literal blacklist
             add b1 clauses to clause blacklist
             pick next element from B that is not in literal blacklist
             pick a clause that is not in
             
             generate_clause_coverage(B: set of literals to cover, C: clauses selected so far, CBL: clause blacklist):
             {
			     if B is empty
				     yield C
			     let b = B[0]
				 CBL_new = CBL union b.clauses
				 if b.clauses is subset of CBL
				     generate_clause_coverage(B minus b, C, CBL)
				 for b_Clause in b.clauses minus CBL
				 {
					 generate_clause_coverage(B minus b_Clause.literals, C union {b_Clause}, CBL_new)
				 }
             }
  		
  		
  		
  	     Keep a set of clauses for each literal:  Clauses(l)
  	     Given a partial assignment, 
  	        Initialize S (set of clauses) to empty
  	        Initialize T (union of clauses containing literals for which choices have been made so far) to empty
  	        
  	        for each literal l in the partial assignment
  	           for each clause c in Clauses(l)
  	              if 
  	       
